<body><div><div class="post" id="post">
							<div class="post-info">			
					<p class="post-title-info">
						</p><h2 class="post-title">Interval Tree</h2>
								
					<p class="clear"></p>				  
				<div class="post-content" id="post-content">
					<p>Consider a situation where we have a set of intervals and we need following operations to be implemented efficiently.  <span id="more-125741"></span><br>
<strong>1) </strong>Add an interval<br>
<strong>2) </strong>Remove an interval<br>
<strong>3)</strong> Given an interval x, find if x overlaps with any of the existing intervals.</p>
<p><em><strong>Interval Tree:</strong></em> The idea is to augment a self-balancing Binary Search Tree (BST) like <a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/" target="_blank">Red Black Tree</a>, <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">AVL Tree</a>, etc to maintain set of intervals so that all operations can be done in O(Logn) time.  </p>
<p>Every node of Interval Tree stores following information.<br>
a) <strong>i</strong>: An interval which is represented as a pair <em>[low, high]</em><br>
b) <strong>max</strong>: Maximum <em>high </em> value in subtree rooted with this node.</p>
<p>The low value of an interval is used as key to maintain order in BST. The insert and delete operations are same as insert and delete in self-balancing BST used. </p>
<p><a href="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/IntervalSearcTree.png"><img src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/IntervalSearcTree.png" alt="IntervalSearcTree" width="416" height="250" class="aligncenter size-full wp-image-127586"></a></p>
<p>The main operation is to search for an overlapping interval.  Following is algorithm for searching an overlapping interval <em>x</em> in an Interval tree rooted with <em>root</em>.
</p><pre>
Interval overlappingIntervalSearch(root, x)
<strong>1) </strong>If x overlaps with root's interval, return the root's interval.

<strong>2)</strong> If left child of root is not empty and the <em>max </em> in left child 
is greater than x's low value, recur for left child

<strong>3)</strong> Else recur for right child.
</pre>
<p><em><strong>How does the above algorithm work?</strong></em><br>
Let the interval to be searched be x. We need to prove this in for following two cases.</p>
<p><em><strong>Case 1:</strong></em> <em>When we go to right subtree, one of the following must be true.</em><br>
a) There is an overlap in right subtree: This is fine as we need to return one overlapping interval.<br>
b) There is no overlap in either subtree: We go to right subtree only when either left is NULL or maximum value in left is smaller than <em>x.low</em>.  So the interval cannot be present in left subtree.</p>
<p><em><strong>Case 2: </strong></em><em>When we go to left subtree, one of the following must be true.</em><br>
a) There is an overlap in left subtree: This is fine as we need to return one overlapping interval.<br>
b) There is no overlap in either subtree:  This is the most important part.  We need to consider following facts.<br>
&#8230;  We went to left subtree because <em>x.low  in left subtree<br>
&#8230;. max in left subtree is a high of one of the intervals let us say <em>[a, max]</em> in left subtree.<br>
&#8230;. Since <em>x</em> doesn&#8217;t overlap with any node in left subtree <em>x.low</em> must be smaller than &#8216;<em>a</em>&#8216;.<br>
&#8230;. All nodes in BST are ordered by low value, so all nodes in right subtree must have low value greater than &#8216;<em>a</em>&#8216;.<br>
&#8230;. From above two facts, we can say all intervals in right subtree have low value greater than <em>x.low</em>.  So<em> x</em> cannot overlap with any interval in right subtree.</em></p>
<p><strong>Implementation of Interval Tree:</strong><br>
Following is C++ implementation of Interval Tree. The implementation uses basic <a href="http://geeksquiz.com/binary-search-tree-set-1-search-and-insertion/" target="_blank">insert operation of BST</a> to keep things simple. Ideally it should be <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">insertion of AVL Tree</a> or <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">insertion of Red-Black Tree</a>.  <a href="http://geeksquiz.com/binary-search-tree-set-2-delete/" target="_blank">Deletion from BST</a> is left as an exercise.</p>
<pre class="brush: cpp; highlight: [27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82]; title: ; notranslate" title="">
#include &lt;iostream&gt;
using namespace std;

// Structure to represent an interval
struct Interval
{
    int low, high;
};

// Structure to represent a node in Interval Search Tree
struct ITNode
{
    Interval *i;  // 'i' could also be a normal variable
    int max;
    ITNode *left, *right;
};

// A utility function to create a new Interval Search Tree Node
ITNode * newNode(Interval i)
{
    ITNode *temp = new ITNode;
    temp-&gt;i = new Interval(i);
    temp-&gt;max = i.high;
    temp-&gt;left = temp-&gt;right = NULL;
};

// A utility function to insert a new Interval Search Tree Node
// This is similar to BST Insert.  Here the low value of interval
// is used tomaintain BST property
ITNode *insert(ITNode *root, Interval i)
{
    // Base case: Tree is empty, new node becomes root
    if (root == NULL)
        return newNode(i);

    // Get low value of interval at root
    int l = root-&gt;i-&gt;low;

    // If root's low value is smaller, then new interval goes to
    // left subtree
    if (i.low &lt; l)
        root-&gt;left = insert(root-&gt;left, i);

    // Else, new node goes to right subtree.
    else
        root-&gt;right = insert(root-&gt;right, i);

    // Update the max value of this ancestor if needed
    if (root-&gt;max &lt; i.high)
        root-&gt;max = i.high;

    return root;
}

// A utility function to check if given two intervals overlap
bool doOVerlap(Interval i1, Interval i2)
{
    if (i1.low &lt;= i2.high &amp;&amp; i2.low &lt;= i1.high)
        return true;
    return false;
}

// The main function that searches a given interval i in a given
// Interval Tree.
Interval *overlapSearch(ITNode *root, Interval i)
{
    // Base Case, tree is empty
    if (root == NULL) return NULL;

    // If given interval overlaps with root
    if (doOVerlap(*(root-&gt;i), i))
        return root-&gt;i;

    // If left child of root is present and max of left child is
    // greater than or equal to given interval, then i may
    // overlap with an interval is left subtree
    if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;max &gt;= i.low)
        return overlapSearch(root-&gt;left, i);

    // Else interval can only overlap with right subtree
    return overlapSearch(root-&gt;right, i);
}

void inorder(ITNode *root)
{
    if (root == NULL) return;

    inorder(root-&gt;left);

    cout &lt;&lt; "[" &lt;&lt; root-&gt;i-&gt;low &lt;&lt; ", " &lt;&lt; root-&gt;i-&gt;high &lt;&lt; "]"
         &lt;&lt; " max = " &lt;&lt; root-&gt;max &lt;&lt; endl;

    inorder(root-&gt;right);
}

// Driver program to test above functions
int main()
{
    // Let us create interval tree shown in above figure
    Interval ints[] = {{15, 20}, {10, 30}, {17, 19},
        {5, 20}, {12, 15}, {30, 40}
    };
    int n = sizeof(ints)/sizeof(ints[0]);
    ITNode *root = NULL;
    for (int i = 0; i &lt; n; i++)
        root = insert(root, ints[i]);

    cout &lt;&lt; "Inorder traversal of constructed Interval Tree is\n";
    inorder(root);

    Interval x = {6, 7};

    cout &lt;&lt; "\nSearching for interval [" &lt;&lt; x.low &lt;&lt; "," &lt;&lt; x.high &lt;&lt; "]";
    Interval *res = overlapSearch(root, x);
    if (res == NULL)
        cout &lt;&lt; "\nNo Overlapping Interval";
    else
        cout &lt;&lt; "\nOverlaps with [" &lt;&lt; res-&gt;low &lt;&lt; ", " &lt;&lt; res-&gt;high &lt;&lt; "]";
    return 0;
}
</pre>
<p>Output:
</p><pre>Inorder traversal of constructed Interval Tree is
[5, 20] max = 20
[10, 30] max = 30
[12, 15] max = 15
[15, 20] max = 40
[17, 19] max = 40
[30, 40] max = 40

Searching for interval [6,7]
Overlaps with [5, 20]</pre>
<p><strong>Applications of Interval Tree:</strong><br>
Interval tree is mainly a geometric data structure and often used for windowing queries, for instance, to find all roads on a computerized map inside a rectangular viewport, or to find all visible elements inside a three-dimensional scene (Source <a href="http://en.wikipedia.org/wiki/Interval_tree" target="_blank">Wiki</a>).</p>
<p><strong>Interval Tree vs <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank">Segment Tree</a></strong><br>
Both segment and interval trees store intervals.  Segment tree is mainly optimized for queries for a given point, and interval trees are mainly optimized for overlapping queries for a given interval.</p>
<p><strong>Exercise:</strong><br>
1) Implement delete operation for interval tree.<br>
2) Extend the intervalSearch() to print all overlapping intervals instead of just one. </p>
<p><a href="http://en.wikipedia.org/wiki/Interval_tree" target="_blank">http://en.wikipedia.org/wiki/Interval_tree</a><br>
<a href="http://www.cse.unr.edu/~mgunes/cs302/IntervalTrees.pptx" target="_blank">http://www.cse.unr.edu/~mgunes/cs302/IntervalTrees.pptx</a><br>
<a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a><br>
<a href="https://www.youtube.com/watch?v=dQF0zyaym8A" target="_blank">https://www.youtube.com/watch?v=dQF0zyaym8A</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
		
&#160;
&#160;







&#160;
&#160;
&#160;
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a>, <a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></p> 






				<h3>Source:</h3><p><a href="http://www.geeksforgeeks.org/interval-tree/" rel="tag">http://www.geeksforgeeks.org/interval-tree/</a></p></div>		  
			</div> 					
						
        
			</div> 	

</div></body>